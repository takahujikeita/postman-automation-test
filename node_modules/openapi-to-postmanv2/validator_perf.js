/* eslint-disable */

var Converter = require('./index.js'),
  fs = require('fs'),
  _ = require('lodash'),
  path = require('path'),
  VALID_OPENAPI_PATH = './spec',
  // historyObject = require('./historyObject.json'),
  HISTORY_PATH = './collection.json';

var openapi = fs.readFileSync(path.join(__dirname, VALID_OPENAPI_PATH), 'utf8'),
  historyRequest = [];

// getAllRequests(JSON.parse(fs.readFileSync(path.join(__dirname, HISTORY_PATH), 'utf8')), historyRequest);
// historyRequest = [historyObject];

let schemaPack = new Converter.SchemaPack({ type: 'string', data: openapi }, {
  // strictRequestMatching: true,
  // suggestAvailableFixes: true,
  // validateMetadata: true,
  // detailedBlobValidation: true,
  // allowUrlPathVarMatching: true,
  // ignoreUnresolvedVariables: true,
  // showMissingInSchemaErrors: true,
  // optimizeConversion: false,
  // stackLimit: 13,

  // ADP options
  strictRequestMatching: true,
  detailedBlobValidation: false,
  suggestAvailableFixes: true,
  ignoreUnresolvedVariables: true,
  showMissingInSchemaErrors: true,
  validateMetadata: true,
  parametersResolution: 'Example',
  folderStrategy: 'tags',
  tagsFolderHierarchy: 'nested'
  // stackLimit: 50


  // includeExampleChanges: true,
  // includeDescriptiveChanges: true,
  // includeOptionalChanges: true

  // suggestAvailableFixes: true

  // RUNTIME options
  // detailedBlobValidation: true,
  // allowUrlPathVarMatching: true

  // suggestAvailableFixes: true,
  // showMissingInSchemaErrors: true

  // showMissingInSchemaErrors: true,
  // strictRequestMatching: true,
  // ignoreUnresolvedVariables: true,
  // validateMetadata: true,
  // suggestAvailableFixes: true,
  // detailedBlobValidation: false
});

schemaPack.convertV2((err, results) => {
  fs.writeFileSync('collection.json', JSON.stringify(results.output[0].data, null, 2));
  historyRequest = [];

  // getAllRequests(results.output[0].data, historyRequest);

  // schemaPack.validateTransactionV2(historyRequest, (err, result) => {
  //   let sameMismatches = [];
  //   // result is as described in the Schema <> Validation Doc
  //   console.log(err);
  
  //   _.forEach(result.requests, (req) => {
  //     if (req.endpoints && req.endpoints.length > 1) {
  //       _.unset(req.endpoints, '[1]');
  //       _.unset(req.endpoints, '[2]');
  //       _.unset(req.endpoints, '[3]');
  //     }
  
  //     if (req.endpoints[0]) {
  //       if (req.endpoints[0].mismatches) {
  //         _.forEach(req.endpoints[0].mismatches, (mm) => {
  //           if (mm.suggestedFix && _.isEqual(mm.suggestedFix.actualValue, mm.suggestedFix.suggestedValue)) {
  //             sameMismatches.push({
  //               endpoint: req.endpoints[0].endpoint,
  //               mm
  //             });
  //           }
  //         });
  //       }
  
  //       _.forEach(req.endpoints[0].responses, (res) => {
  //         if (res.mismatches) {
  //           _.forEach(res.mismatches, (mm) => {
  //             if (mm.suggestedFix && _.isEqual(mm.suggestedFix.actualValue, mm.suggestedFix.suggestedValue)) {
  //               sameMismatches.push({
  //                 endpoint: req.endpoints[0].endpoint + '.responses',
  //                 mm
  //               });
  //             }
  //           });
  //         }
  //       });
  //     }
  //   });
  //   // fs.writeFileSync('sameMm.json', JSON.stringify(sameMismatches, null, 2));
  
  //   fs.writeFileSync('result.json', JSON.stringify(result, null, 2));
  // });
  
  // console.log(err, results);
});

historyRequest = [];

// getAllRequests(JSON.parse(fs.readFileSync(path.join(__dirname, HISTORY_PATH), 'utf8')), historyRequest);

// schemaPack.validateTransactionV2(historyRequest, (err, result) => {
//   let sameMismatches = [];
//   // result is as described in the Schema <> Validation Doc
//   console.log(err);

//   _.forEach(result.requests, (req) => {
//     if (req.endpoints && req.endpoints.length > 1) {
//       _.unset(req.endpoints, '[1]');
//       _.unset(req.endpoints, '[2]');
//       _.unset(req.endpoints, '[3]');
//     }

//     if (req.endpoints[0]) {
//       if (req.endpoints[0].mismatches) {
//         _.forEach(req.endpoints[0].mismatches, (mm) => {
//           if (mm.suggestedFix && _.isEqual(mm.suggestedFix.actualValue, mm.suggestedFix.suggestedValue)) {
//             sameMismatches.push({
//               endpoint: req.endpoints[0].endpoint,
//               mm
//             });
//           }
//         });
//       }

//       _.forEach(req.endpoints[0].responses, (res) => {
//         if (res.mismatches) {
//           _.forEach(res.mismatches, (mm) => {
//             if (mm.suggestedFix && _.isEqual(mm.suggestedFix.actualValue, mm.suggestedFix.suggestedValue)) {
//               sameMismatches.push({
//                 endpoint: req.endpoints[0].endpoint + '.responses',
//                 mm
//               });
//             }
//           });
//         }
//       });
//     }
//   });
//   // fs.writeFileSync('sameMm.json', JSON.stringify(sameMismatches, null, 2));

//   fs.writeFileSync('result.json', JSON.stringify(result, null, 2));
// });

function idstr () {
  return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

function getAllRequests (collection, allRequests) {
  if (!_.has(collection, 'item') || !_.isArray(collection.item)) {
    return;
  }
  _.forEach(collection.item, (item) => {
    if (_.has(item, 'request') || _.has(item, 'response')) {
      // let idstr = _.get(item, 'request.method') + ' ' + _.join(_.get(item, 'request.url.path'), '/');
      allRequests.push(_.assign({}, _.omit(item, ['id', 'response']), {
        id: idstr(),
        response: _.map(item.response, (res) => {
          return _.assign({}, res, { id: idstr() });
        })
      }));
      // allRequests.push(item);
    }
    else {
      getAllRequests(item, allRequests);
    }
  });
};