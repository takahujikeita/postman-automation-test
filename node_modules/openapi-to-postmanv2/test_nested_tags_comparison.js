const { convertV2 } = require('./libV2/index.js');

// Test spec with nested tags
const nestedTagsSpec = {
  openapi: '3.0.0',
  info: {
    version: '1.0.0',
    title: 'Nested Tags Test'
  },
  tags: [
    {
      name: 'pets',
      description: 'Pet operations'
    },
    {
      name: 'admin',
      description: 'Admin operations'
    },
    {
      name: 'management',
      description: 'Management operations'
    }
  ],
  paths: {
    '/pets': {
      get: {
        summary: 'List pets',
        tags: ['pets', 'admin'],
        responses: {
          '200': {
            description: 'Success'
          }
        }
      }
    },
    '/pets/{petId}': {
      get: {
        summary: 'Get pet by ID',
        tags: ['pets', 'admin', 'management'],
        responses: {
          '200': {
            description: 'Success'
          }
        }
      }
    },
    '/admin/users': {
      get: {
        summary: 'List users',
        tags: ['admin'],
        responses: {
          '200': {
            description: 'Success'
          }
        }
      }
    },
    '/health': {
      get: {
        summary: 'Health check',
        responses: {
          '200': {
            description: 'Success'
          }
        }
      }
    }
  }
};

console.log('=== Testing Original Tags Strategy ===');

// Test with original tags strategy
const contextOriginal = {
  openapi: nestedTagsSpec,
  computedOptions: {
    folderStrategy: 'tags',
    includeDeprecated: false,
    includeWebhooks: false
  }
};

convertV2(contextOriginal, (err, result) => {
  if (err) {
    console.error('Error:', err);
    return;
  }

  console.log('Original Tags Strategy - Collection structure:');
  
  function printStructure(item, indent = '') {
    if (!item) {
      console.log(`${indent}❌ No item`);
      return;
    }
    if (item.item) {
      console.log(`${indent}📁 ${item.name || 'Collection'}`);
      item.item.forEach(subItem => printStructure(subItem, indent + '  '));
    } else {
      console.log(`${indent}📄 ${item.name || 'Unnamed'} (${item.request ? item.request.method : 'N/A'})`);
    }
  }
  
  // Access the collection data correctly
  const collection = result.output[0].data;
  printStructure(collection);
  
  console.log('\n=== Testing Nested Tags Strategy ===');
  
  // Test with nested tags strategy
  const contextNested = {
    openapi: nestedTagsSpec,
    computedOptions: {
      folderStrategy: 'tags',
      nestedFolderHierarchy: true,
      includeDeprecated: false,
      includeWebhooks: false
    }
  };

  convertV2(contextNested, (err, nestedResult) => {
    if (err) {
      console.error('Error:', err);
      return;
    }

    console.log('Nested Tags Strategy - Collection structure:');
    const nestedCollection = nestedResult.output[0].data;
    printStructure(nestedCollection);
    
    console.log('\n=== Comparison Summary ===');
    console.log('Original: Creates separate folders for each tag with duplicate requests');
    console.log('Nested: Creates hierarchical folder structure based on tag order');
  });
});
